<p>Class: GraphQL::Schema::RelayClassicMutation &lt; GraphQL::Schema::Muta…
Mutations that extend this base class get some conventions added for
free:</p>
<ul>
  <li>An argument called <code class="highlighter-rouge">clientMutationId</code> is <em>always</em> added, but it’s
not passed
to the resolve method. The value is re-inserted to the response.
(It’s for
client libraries to manage optimistic updates.)</li>
  <li>The returned object type always has a field called
<code class="highlighter-rouge">clientMutationId</code> to support that. - The mutation accepts one
argument called <code class="highlighter-rouge">input</code>, <code class="highlighter-rouge">argument</code>s defined in the mutation
class are added to that input object, which is generated by the
mutation.
These conventions were first specified by Relay Classic, but they
come in handy:</li>
  <li><code class="highlighter-rouge">clientMutationId</code> supports optimistic updates and cache rollbacks
on the client - using a single <code class="highlighter-rouge">input:</code> argument makes it easy to
post whole JSON objects to the mutation
using one GraphQL variable (<code class="highlighter-rouge">$input</code>) instead of making a separate
variable for each argument.
See Also:</li>
  <li>{GraphQL::Schema::Mutation} - for an example, it’s basically the same.
Class methods:
field_options, generate_input_type, input_object_class, input_type
Instance methods:
resolve_with_support</li>
</ul>

